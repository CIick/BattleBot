"""
Enhanced Wizard101 Spell Template DTOs
=====================================
Comprehensive Data Transfer Objects for Wizard101 spell templates and nested types.

This module contains:
- 14 DTO classes with proper inheritance
- 9 enum definitions
- Enhanced factory with polymorphic support
- Full nested object creation capabilities

Generated by enhanced_dto_generator.py for combat simulation
"""

from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Union, Type
from enum import Enum

# ===== ENUM DEFINITIONS =====

class kSpellSourceType(Enum):
    kCaster = 0
    kPet = 1
    kShadowCreature = 2
    kWeapon = 3
    kEquipment = 4

class kDelayOrder(Enum):
    SpellEffect_kAnyOrder = 0
    SpellEffect_kFirst = 1
    SpellEffect_kSecond = 2

class GardenSpellType(Enum):
    GS_SoilPreparation = 0
    GS_Growing = 1
    GS_InsectFighting = 2
    GS_PlantProtection = 3
    GS_PlantUtility = 4

class UtilitySpellType(Enum):
    US_None = 0
    US_Zap = 1
    US_Revive = 2
    US_Inspect = 3
    US_Stasis = 4
    US_PlowAll = 5
    US_PlantAll = 6
    US_HarvestNow = 7

class CastleMagicSpellType(Enum):
    CM_Action = 0
    CM_Effect = 1
    CM_Utility = 2
    CM_Logic = 3

class CastleMagicSpellEffect(Enum):
    CM_None = 0
    CM_MakeInvisible = 1
    CM_MakeVisible = 2
    CM_PlaySpellEffect = 3
    CM_PlaySoundEffect = 4

class FishingSpellType(Enum):
    FS_Catching = 0
    FS_Utility = 1
    FS_PredatorBanishment = 2

class CantripsSpellType(Enum):
    CS_Teleportation = 0
    CS_Incantation = 1
    CS_Beneficial = 2
    CS_Ritual = 3
    CS_Sigil = 4

class CantripsSpellEffect(Enum):
    CSE_None = 0
    CSE_PlayEffect = 1
    CSE_Mark = 2
    CSE_Recall = 3
    CSE_Heal = 4

# ===== BASE DTO CLASSES =====

@dataclass
class ReqGardeningLevelDTO:
    """Base DTO for ReqGardeningLevel"""
    m_applyNOT: bool
    m_numericValue: float
    m_operator: int
    m_operatorType: int

@dataclass
class ReqHasBadgeDTO:
    """Base DTO for ReqHasBadge"""
    m_applyNOT: bool
    m_badgeName: str
    m_operator: int

@dataclass
class ReqMagicLevelDTO:
    """Base DTO for ReqMagicLevel"""
    m_applyNOT: bool
    m_magicSchool: str
    m_numericValue: float
    m_operator: int
    m_operatorType: int

@dataclass
class RequirementListDTO:
    """Base DTO for RequirementList"""
    m_applyNOT: bool
    m_operator: int
    m_requirements: List[ReqHasBadgeDTO]

@dataclass
class SpellEffectDTO:
    """Base DTO for SpellEffect"""
    m_act: bool
    m_actNum: int
    m_armorPiercingParam: int
    m_bypassProtection: bool
    m_chancePerTarget: int
    m_cloaked: bool
    m_converted: bool
    m_damageType: int
    m_disposition: int
    m_effectParam: int
    m_effectTarget: int
    m_effectType: int
    m_enchantmentSpellTemplateID: int
    m_healModifier: float
    m_numRounds: int
    m_paramPerRound: int
    m_pipNum: int
    m_protected: bool
    m_rank: int
    m_sDamageType: str
    m_spellTemplateID: int

@dataclass
class SpellRankDTO:
    """Base DTO for SpellRank"""
    m_balancePips: int
    m_deathPips: int
    m_firePips: int
    m_icePips: int
    m_lifePips: int
    m_mythPips: int
    m_shadowPips: int
    m_spellRank: int
    m_stormPips: int
    m_xPipSpell: bool

@dataclass
class SpellTemplateDTO:
    """Base DTO for SpellTemplate"""
    m_PvE: bool
    m_PvP: bool
    m_Treasure: bool
    m_accuracy: int
    m_adjectives: List[Any]
    m_advancedDescription: str
    m_alwaysFizzle: bool
    m_backRowFriendly: bool
    m_baseCost: int
    m_battlegroundsOnly: bool
    m_behaviors: List[Any]
    m_boosterPackIcon: str
    m_cardFront: str
    m_casterInvisible: bool
    m_cloaked: bool
    m_cloakedName: str
    m_creditsCost: int
    m_delayEnchantment: bool
    m_delayEnchantmentOrder: Any
    m_description: str
    m_descriptionCombatHUD: str
    m_descriptionTrainer: str
    m_displayIndex: int
    m_displayName: str
    m_displayRequirements: Optional[Any]
    m_effects: List[SpellEffectDTO]
    m_hiddenFromEffectsWindow: bool
    m_ignoreCharms: bool
    m_ignoreDispel: bool
    m_imageIndex: int
    m_imageName: str
    m_leavesPlayWhenCast: bool
    m_levelRestriction: int
    m_maxCopies: int
    m_name: str
    m_noDiscard: bool
    m_noPvEEnchant: bool
    m_noPvPEnchant: bool
    m_previousSpellName: str
    m_purchaseRequirements: Optional[Any]
    m_pvpCurrencyCost: int
    m_pvpTourneyCurrencyCost: int
    m_requiredSchoolName: str
    m_sMagicSchoolName: str
    m_sTypeName: str
    m_secondarySchoolName: str
    m_showPolymorphedName: bool
    m_skipTruncation: bool
    m_spellBase: str
    m_spellCategory: str
    m_spellFusion: int
    m_spellRank: SpellRankDTO
    m_spellSourceType: int
    m_trainingCost: int
    m_useGloss: bool
    m_validTargetSpells: List[Any]

# ===== DERIVED DTO CLASSES =====

@dataclass
class CantripsSpellTemplateDTO(SpellTemplateDTO):
    """DTO for CantripsSpellTemplate - inherits from SpellTemplateDTO"""
    m_animationKFMs: List[Any]
    m_animationNames: List[str]
    m_cantripsSpellEffect: int
    m_cantripsSpellImageIndex: int
    m_cantripsSpellImageName: str
    m_cantripsSpellType: int
    m_cooldownSeconds: int
    m_effectParameter: str
    m_energyCost: int
    m_soundEffectGain: float
    m_soundEffectName: str

@dataclass
class CastleMagicSpellTemplateDTO(SpellTemplateDTO):
    """DTO for CastleMagicSpellTemplate - inherits from SpellTemplateDTO"""
    m_animationKFM: str
    m_animationSequence: str
    m_castleMagicSpellEffect: int
    m_castleMagicSpellType: int
    m_effectSchool: str

@dataclass
class FishingSpellTemplateDTO(SpellTemplateDTO):
    """DTO for FishingSpellTemplate - inherits from SpellTemplateDTO"""
    m_animationKFM: str
    m_animationName: str
    m_energyCost: int
    m_fishingSchoolFocus: str
    m_fishingSpellImageIndex: int
    m_fishingSpellImageName: str
    m_fishingSpellType: int
    m_soundEffectGain: float
    m_soundEffectName: str

@dataclass
class GardenSpellTemplateDTO(SpellTemplateDTO):
    """DTO for GardenSpellTemplate - inherits from SpellTemplateDTO"""
    m_affectedRadius: int
    m_animationKFM: str
    m_animationName: str
    m_animationNameLarge: str
    m_animationNameSmall: str
    m_bugZapLevel: int
    m_energyCost: int
    m_gardenSpellImageIndex: int
    m_gardenSpellImageName: str
    m_gardenSpellType: int
    m_protectionTemplateID: int
    m_providesMagic: bool
    m_providesMusic: bool
    m_providesPollination: bool
    m_providesSun: bool
    m_providesWater: bool
    m_soilTemplateID: int
    m_soundEffectGain: float
    m_soundEffectName: str
    m_utilitySpellType: int
    m_yOffset: float

@dataclass
class RandomSpellEffectDTO(SpellEffectDTO):
    """DTO for RandomSpellEffect - inherits from SpellEffectDTO"""
    m_effectList: List[SpellEffectDTO]

@dataclass
class TieredSpellTemplateDTO(SpellTemplateDTO):
    """DTO for TieredSpellTemplate - inherits from SpellTemplateDTO"""
    m_nextTierSpells: List[str]
    m_requirements: RequirementListDTO
    m_retired: bool
    m_shardCost: int

@dataclass
class WhirlyBurlySpellTemplateDTO(SpellTemplateDTO):
    """DTO for WhirlyBurlySpellTemplate - inherits from SpellTemplateDTO"""
    m_specialUnits: str
    m_unitMovement: str

# ===== ENHANCED FACTORY =====

class EnhancedSpellDTOFactory:
    """Enhanced factory for creating spell DTOs with full polymorphic support"""
    
    # Hash to DTO class mapping
    TYPE_MAPPING: Dict[int, Type] = {
        1864220976: SpellTemplateDTO,
        1225309305: SpellEffectDTO,
        853452777: SpellRankDTO,
        1015536062: TieredSpellTemplateDTO,
        1906855338: RandomSpellEffectDTO,
        1558190673: RequirementListDTO,
        258825572: ReqMagicLevelDTO,
        1087768358: CastleMagicSpellTemplateDTO,
        108720390: GardenSpellTemplateDTO,
        710415701: ReqGardeningLevelDTO,
        2095072282: FishingSpellTemplateDTO,
        443110133: CantripsSpellTemplateDTO,
        1914767513: ReqHasBadgeDTO,
        1093865471: WhirlyBurlySpellTemplateDTO,
    }
    
    # Polymorphic type mapping (for Union types)
    POLYMORPHIC_MAPPING: Dict[str, List[Type]] = {
        "SpellTemplateDTO": [TieredSpellTemplateDTO, CastleMagicSpellTemplateDTO, GardenSpellTemplateDTO, FishingSpellTemplateDTO, CantripsSpellTemplateDTO, WhirlyBurlySpellTemplateDTO],
        "SpellEffectDTO": [RandomSpellEffectDTO],
    }
    
    @classmethod
    def create_dto(cls, type_hash: int, spell_data: Dict[str, Any]) -> Optional[Any]:
        """Create appropriate DTO instance based on type hash"""
        dto_class = cls.TYPE_MAPPING.get(type_hash)
        if dto_class:
            try:
                # Convert nested objects recursively
                processed_data = cls.process_nested_objects(spell_data)
                
                # Filter data to only include fields that exist in the DTO
                filtered_data = cls.filter_data_for_dto(dto_class, processed_data)
                
                # Create the DTO instance
                return dto_class(**filtered_data)
            except Exception as e:
                print(f"Error creating DTO for hash {type_hash}: {e}")
                return None
        else:
            print(f"No DTO class found for hash {type_hash}")
            return None
    
    @classmethod
    def process_nested_objects(cls, data: Dict[str, Any]) -> Dict[str, Any]:
        """Recursively process nested objects to create DTOs"""
        if not isinstance(data, dict):
            return data
        
        processed = {}
        
        for key, value in data.items():
            if isinstance(value, dict) and "$__type" in value:
                # This is a nested typed object - find its hash and create DTO
                nested_type = value["$__type"].replace("class ", "")
                
                # Find the hash for this type
                nested_hash = cls.find_hash_for_type(nested_type)
                if nested_hash:
                    processed[key] = cls.create_dto(nested_hash, value)
                else:
                    processed[key] = value
            
            elif isinstance(value, list):
                # Process list items
                processed_list = []
                for item in value:
                    if isinstance(item, dict) and "$__type" in item:
                        nested_type = item["$__type"].replace("class ", "")
                        nested_hash = cls.find_hash_for_type(nested_type)
                        if nested_hash:
                            processed_list.append(cls.create_dto(nested_hash, item))
                        else:
                            processed_list.append(item)
                    else:
                        processed_list.append(item)
                processed[key] = processed_list
            
            else:
                processed[key] = value
        
        return processed
    
    @classmethod
    def find_hash_for_type(cls, type_name: str) -> Optional[int]:
        """Find hash value for a given type name"""
        for hash_val, dto_class in cls.TYPE_MAPPING.items():
            if dto_class.__name__ == f"{type_name}DTO":
                return hash_val
        return None
    
    @classmethod
    def filter_data_for_dto(cls, dto_class: Type, data: Dict[str, Any]) -> Dict[str, Any]:
        """Filter data to only include fields that exist in the DTO class"""
        if hasattr(dto_class, "__annotations__"):
            valid_fields = set(dto_class.__annotations__.keys())
            return {k: v for k, v in data.items() if k in valid_fields}
        return data
    
    @classmethod
    def get_supported_hashes(cls) -> List[int]:
        """Get list of all supported type hashes"""
        return list(cls.TYPE_MAPPING.keys())
    
    @classmethod
    def get_polymorphic_types(cls) -> Dict[str, List[Type]]:
        """Get polymorphic type mappings"""
        return cls.POLYMORPHIC_MAPPING.copy()
    
    @classmethod
    def create_from_json_data(cls, json_data: Dict[str, Any]) -> Optional[Any]:
        """Create DTO from raw JSON data (with $__type field)"""
        if "$__type" not in json_data:
            print("No $__type field found in JSON data")
            return None
        
        type_name = json_data["$__type"].replace("class ", "")
        type_hash = cls.find_hash_for_type(type_name)
        
        if type_hash:
            return cls.create_dto(type_hash, json_data)
        else:
            print(f"No hash found for type: {type_name}")
            return None